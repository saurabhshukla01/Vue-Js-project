vue >  2
php > 7.2

Need to learn & create Program in the same ....

# parent to child connectivity for vue js
# child to parent
# how to make reactive child passing data from parent
# lifeCycle in vue Js
# which lifeCycle is used when Dom is called 
# how to pass data from child to parent in lifeCycle method
# how to find function is called vue Js
# what is watch & how to use watch 
# what is computed & how to use it
# between computed & methods
# find , filter , foreach , map method in JS 
# mixin methods in vue
# proto types

+++++++++++++++++++++++++++++++++++++++++++++++

#How to handle multiple data type in parent to child & check child is reactive data updation .
#watch where to use it 


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


<template>
  <div>
    <h1>User Profile</h1>
    <input v-model="localName" placeholder="Enter your name" />
    <input v-model="localEmail" placeholder="Enter your email" />
    <p>Full Name: {{ fullName }}</p>
    <p>Email: {{ localEmail }}</p>
    <button @click="resetProfile">Reset Profile</button>
  </div>
</template>

<script>
export default {
  props: {
    initialName: {
      type: String,
      required: true
    },
    initialEmail: {
      type: String,
      required: true
    }
  },
  data() {
    return {
      localName: this.initialName,
      localEmail: this.initialEmail
    };
  },
  computed: {
    fullName() {
      return this.localName;
    }
  },
  watch: {
    localName(newValue, oldValue) {
      console.log(`Name changed from "${oldValue}" to "${newValue}"`);
    },
    localEmail(newValue, oldValue) {
      console.log(`Email changed from "${oldValue}" to "${newValue}"`);
    }
  },
  created() {
    console.log("Component created: Initial data setup.");
  },
  beforeMount() {
    console.log("Component beforeMount: Template is not yet rendered.");
  },
  mounted() {
    console.log("Component mounted: Template has been rendered.");
  },
  beforeUpdate() {
    console.log("Component beforeUpdate: Data has changed but the DOM is not yet updated.");
  },
  updated() {
    console.log("Component updated: DOM has been updated with the new data.");
  },
  beforeDestroy() {
    console.log("Component beforeDestroy: Component is about to be destroyed.");
  },
  destroyed() {
    console.log("Component destroyed: Component has been destroyed.");
  },
  methods: {
    resetProfile() {
      // Reset the profile to the initial props values
      this.localName = this.initialName;
      this.localEmail = this.initialEmail;
      console.log("Profile reset to initial values.");
    }
  }
};
</script>

<style scoped>
h1 {
  font-family: Arial, sans-serif;
}
input {
  margin-bottom: 10px;
  display: block;
}
button {
  padding: 10px;
  background-color: #007bff;
  color: white;
  border: none;
  cursor: pointer;
}
</style>



Explanation
1. Props
Usage: Props are used to pass data from a parent component to a child component. In this example, initialName and initialEmail are passed as props.
Why Use: Props allow the child component to be configurable based on the parent component's data, making the component reusable and more flexible.
2. Data
Usage: The data function returns an object that contains localName and localEmail, which are bound to the input fields.
Why Use: Data properties are reactive and allow the component to manage and display its internal state.
3. Computed Properties
Usage: The fullName computed property is derived from localName. Computed properties are cached based on their reactive dependencies.
Why Use: Computed properties provide a way to calculate and derive values based on component data in a performant manner.
4. Watchers
Usage: watch is used to react to changes in localName and localEmail. It logs the changes to the console.
Why Use: Watchers allow you to perform side effects when data changes, such as logging, API calls, or triggering other actions.
5. Lifecycle Hooks
created: Called after the component instance has been created. Used to initialize data or perform setup tasks.
beforeMount: Called before the component is mounted to the DOM. Useful for tasks that need to be done before rendering.
mounted: Called after the component is mounted to the DOM. Ideal for DOM manipulations or third-party integrations.
beforeUpdate: Called when the component's data changes but before the DOM is updated. Useful for preparing data before the DOM update.
updated: Called after the DOM has been updated with the new data. Useful for post-update operations.
beforeDestroy: Called right before the component is destroyed. Used to clean up resources, event listeners, or intervals.
destroyed: Called after the component is destroyed. Used for final cleanup tasks.
6. Methods
Usage: The resetProfile method resets the input fields to their initial values.
Why Use: Methods handle component logic and interactions, providing ways to modify data or perform actions in response to user events.
Console Output Flow
Creation: "Component created: Initial data setup."
Before Mount: "Component beforeMount: Template is not yet rendered."
Mounted: "Component mounted: Template has been rendered."
Input Change: Each time localName or localEmail changes, the corresponding watcher logs the change.
Before Update: "Component beforeUpdate: Data has changed but the DOM is not yet updated."
Updated: "Component updated: DOM has been updated with the new data."
Destroy: When you click "Reset Profile", you can see logs for the destroy lifecycle hooks if you manually trigger component destruction.
This example covers the use of props for data passing, data binding for managing component state, computed properties for derived values, watchers for reacting to data changes, and lifecycle hooks for managing different phases of the component's lifecycle.


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ParentComponent.vue   >>>>>

<template>
    <div>
      <h1>Parent Component</h1>
      <!-- Pass multiple data types as props to the child -->
      <ChildComponent
        :userName="name"
        :userAge="age"
        :isActive="activeStatus"
        :userHobbies="hobbies"
        :userProfile="profile"
      />
  
      <hr />
  
      <!-- UI controls to update props from the parent -->
      <button @click="updateName">Update Name</button>
      <button @click="updateAge">Update Age</button>
      <button @click="toggleActiveStatus">Toggle Active Status</button>
      <button @click="updateHobbies">Add Hobby</button>
      <button @click="updateProfile">Update Profile</button>
    </div>
  </template>
  
  <script>
  import ChildComponent from './ChildComponent.vue';
  
  export default {
    components: {
      ChildComponent
    },
    data() {
      return {
        name: 'Saurabh Shukla',
        age: 30,
        activeStatus: true,
        hobbies: ['Coding', 'Reading', 'Cycling'],
        profile: {
          city: 'New Delhi',
          country: 'India'
        }
      };
    },
    methods: {
      updateName() {
        this.name = 'Saurabh Raj';
      },
      updateAge() {
        this.age += 1; // Increment age
      },
      toggleActiveStatus() {
        this.activeStatus = !this.activeStatus; // Toggle boolean
      },
      updateHobbies() {
        this.hobbies.push('Gaming'); // Add new hobby to the array
      },
      updateProfile() {
        this.profile.city = 'Mumbai'; // Update a nested object property
      }
    }
  };
  </script>
  
  <style scoped>
  button {
    margin: 5px;
    padding: 10px;
  }
  </style>
  

ChildComponent.vue    >>>>>


<template>
  <div>
    <h2>Child Component</h2>
    <p><strong>Name:</strong> {{ userName }}</p>
    <p><strong>Age:</strong> {{ userAge }}</p>
    <p><strong>Active Status:</strong> {{ isActive ? 'Active' : 'Inactive' }}</p>
    <p><strong>Hobbies:</strong></p>
    <ul>
      <li v-for="(hobby, index) in userHobbies" :key="index">{{ hobby }}</li>
    </ul>
    <p><strong>Location:</strong> {{ userProfile.city }}, {{ userProfile.country }}</p>
  </div>
</template>

<script>
export default {
  props: {
    userName: {
      type: String,
      required: true
    },
    userAge: {
      type: Number,
      required: true
    },
    isActive: {
      type: Boolean,
      required: true
    },
    userHobbies: {
      type: Array,
      required: true
    },
    userProfile: {
      type: Object,
      required: true
    }
  },
  watch: {
    userName(newVal, oldVal) {
      console.log(`Name changed from ${oldVal} to ${newVal}`);
    },
    userAge(newVal, oldVal) {
      console.log(`Age changed from ${oldVal} to ${newVal}`);
    },
    isActive(newVal) {
      console.log(`Active status changed to ${newVal}`);
    },
    userHobbies(newVal) {
      console.log(`Hobbies updated: ${newVal.join(', ')}`);
    },
    userProfile: {
      deep: true, // Watching nested object changes
      handler(newVal) {
        console.log(`Profile updated to: ${newVal.city}, ${newVal.country}`);
      }
    }
  }
};
</script>

<style scoped>
p {
  margin: 5px 0;
}
</style>



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=


Notes :  

Explanation
1. Props in Child Component
Props Declaration: In ChildComponent.vue, we declare props for each data type.
userName (String)
userAge (Number)
isActive (Boolean)
userHobbies (Array)
userProfile (Object)
Reactivity: The props received by the child component are reactive. If the parent updates these props, the child component will automatically update the UI.
2. Handling Multiple Data Types
In the parent component, we pass values of different types (string, number, array, object, boolean) to the child using Vue's v-bind syntax (:) to make them reactive.
In the child, we simply access these props and render them.
3. Reactivity in Child
Watchers: The child component uses Vue's watch feature to log changes in the props it receives. Whenever the parent modifies a prop value, the watcher logs the old and new values.
deep: true in watch allows us to detect changes to nested properties inside objects (like profile.city).
4. Parent-to-Child Updates
Updating Data in Parent: The parent component provides buttons that allow you to:
Update the name.
Increment the age.
Toggle the active status.
Add a new hobby to the hobbies array.
Update the profile object (e.g., changing the city).
When any of these buttons are clicked, the corresponding data value in the parent component is updated, and those changes are immediately reflected in the child component due to Vue's reactivity system.
5. Watching for Prop Changes in Child
In the watch section of the child component:
We use watchers to monitor changes in props. Each watcher logs the change to the console, showing the old and new values.
The deep option is used for the userProfile object so that nested changes (e.g., changing the city property) are detected.
How Vue Reactivity Works:
Reactivity System: Vue's reactivity system tracks dependencies between data properties and the DOM. When a data property (like a prop passed from the parent) changes, Vue efficiently updates the DOM where necessary.
Parent-Child Prop Updates: When a prop in the parent component changes, the child automatically re-renders the relevant part of the DOM that depends on that prop, making it reactive without extra work.
Conclusion
This example demonstrates how you can handle multiple data types (string, number, boolean, array, and object) between parent and child components in Vue. The child component reacts to updates from the parent, and Vue ensures that the UI stays in sync with the underlying data model, making it a powerful framework for building reactive user interfaces.








